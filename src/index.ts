import { app, BrowserView, BrowserWindow, ipcMain, session, shell } from 'electron';
import { PaneData } from './common';
import { v4 as uuidv4 } from 'uuid';
// eslint-disable-next-line @typescript-eslint/no-var-requires
const paneCss = require("./pane/index.css");

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const HOST_WEBPACK_ENTRY: string;
declare const HOST_PRELOAD_WEBPACK_ENTRY: string;
declare const PANE_VIEW_WEBPACK_ENTRY: string;
declare const PANE_VIEW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}


const entryUrls: { [k: string]: string } = {
  "home": "https://twitter.com/home",
  "explore": "https://twitter.com/explore",
  "notifications": "https://twitter.com/notifications",
  "messages": "https://twitter.com/messages",
  "bookmarks": "https://twitter.com/i/bookmarks",
  "settings": "https://twitter.com/settings",
}

const numSessions = 2;

const createWindow = (): void => {
  // Create the browser window.
  const hostSession = session.fromPartition("host");
  const mainWindow = new BrowserWindow({
    height: 600,
    width: 800,
    webPreferences: {
      preload: HOST_PRELOAD_WEBPACK_ENTRY,
      contextIsolation: false,
      session: hostSession
    },
  });

  // and load the index.html of the app.
  mainWindow.loadURL(HOST_WEBPACK_ENTRY);

  const baseWidth = 320;

  let contentSize: { width: number, height: number } | undefined = undefined;
  let contentOffset: { x: number, y: number } = { x: 0, y: 0 };

  const panes: PaneData[] = [];

  const adjustPanes = () => {
    const views = mainWindow.getBrowserViews();
    const size = mainWindow.getContentSize();

    const contentWidth = contentSize?.width ?? size[0];
    const contentHeight = contentSize?.height ?? size[1];

    const width = baseWidth;//size[0] / views.length;

    for (let i = 0; i < views.length; i++) {
      const left = Math.round(i * width + contentOffset.x);
      const right = Math.round((i + 1) * width + contentOffset.x);
      const top = Math.round(contentOffset.y);
      const bottom = Math.round(contentHeight + contentOffset.y);

      const bounds = { x: left, y: top, width: right - left, height: bottom - top };
      views[i].setBounds(bounds);
    }
  }

  ipcMain.on("log", (event, value) => {
    console.log(value);
  });

  ipcMain.on("background-color", (event, value) => {
    mainWindow.webContents.send("background-color", value);
  });

  ipcMain.on("container-size", (event, value) => {
    contentSize = value;
    adjustPanes()
  });

  ipcMain.on("container-offset", (event, value) => {
    contentOffset = value;
    adjustPanes()
  });

  ipcMain.on("pane-ids", () => {
    mainWindow.webContents.send("pane-ids", panes.map(p => p.id));
  });

  /*
  mainWindow.on("will-resize", adjustPanes);
  mainWindow.on("maximize", adjustPanes);
  */

  const addPane = (url: string, sessionId: string) => {
    const paneSession = session.fromPartition(sessionId, {
      cache: true
    });

    const view = new BrowserView({
      webPreferences: {
        preload: PANE_VIEW_PRELOAD_WEBPACK_ENTRY,
        session: paneSession
      }
    });


    const id = uuidv4();
    const pane: PaneData = {
      id: id,
      canGoBack: false,
      canGoForward: false,
      session: {
        id: uuidv4(),
        user: null
      }
    };

    const channel = `pane-data-${id}`;

    view.webContents.ipc.on("user", (event, user) => {
      pane.session.user = {
        displayName: user.name,
        id: user.id_str,
        profileImageUrl: user.profile_image_url_https,
        screenName: user.screen_name
      }
      mainWindow.webContents.send(channel, pane);
    })
    mainWindow.webContents.send("pane-ids", panes.map(p => p.id));

    panes.push(pane);

    ipcMain.on(channel, () => {
      mainWindow.webContents.send(channel, pane);
    });
    mainWindow.webContents.send(channel, pane);

    mainWindow.addBrowserView(view);
    view.webContents.loadURL(url);
    view.webContents.setWindowOpenHandler(({ url }) => {
      const urlObj = new URL(url);
      const protocol = urlObj.protocol;
      if (protocol === "http:" || protocol === "https:") {
        shell.openExternal(url);
      }
      return { action: 'deny' }
    })
    view.webContents.on("did-finish-load", () => {
      view.webContents.setZoomFactor(0.8);
      view.webContents.insertCSS(paneCss, {
        cssOrigin: "user"
      })
    });

    //view.webContents.openDevTools();

    adjustPanes();
  }

  mainWindow.webContents.on("did-finish-load", () => {

    mainWindow.getBrowserViews().forEach(v => mainWindow.removeBrowserView(v));
    panes.splice(0);

    //addPane("https://twitter.com/home");
    for (const entryUrl of Object.values(entryUrls)) {
      for(let s = 0; s < numSessions; s++)
      {
        addPane(entryUrl, `persist:decktron/pane-${s}`);
      }
    }
  })

};


// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', () => {

  createWindow()
});

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
